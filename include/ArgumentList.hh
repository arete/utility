/*
 * --- GSMP-COPYRIGHT-NOTE-BEGIN ---
 * 
 * This copyright note is auto-generated by ./scripts/Create-CopyPatch.
 * Please add additional copyright information _after_ the line containing
 * the GSMP-COPYRIGHT-NOTE-END tag. Otherwise it might get removed by
 * the ./scripts/Create-CopyPatch script. Do not edit this copyright text!
 * 
 * GSMP: utility/include/ArgumentList.hh
 * General Sound Manipulation Program is Copyright (C) 2000 - 2004
 *   Valentin Ziegler and René Rebe
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2. A copy of the GNU General
 * Public License can be found in the file LICENSE.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANT-
 * ABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
 * Public License for more details.
 * 
 * --- GSMP-COPYRIGHT-NOTE-END ---
 */

/* Short Description:
 *   Object oriented argument list parsing.
 */

#ifndef UTILITY__ARGUMENTLIST_HH__
#define UTILITY__ARGUMENTLIST_HH__

#include <iostream>

#include <map>
#include <vector>

class BasicArgument {
 public:
  
  BasicArgument (const std::string& i_sname, const std::string& i_lname,
		 const std::string& i_desc,  int i_min_count, int i_max_count,
		 bool i_fragmented);
  
  virtual ~BasicArgument ();
  
  virtual bool Read () = 0;
  virtual bool Read (const std::string& arg) = 0;
  
  virtual bool Interrupt () = 0;
  virtual bool Finalize () = 0;
  
  std::string sname;
  std::string lname;
  std::string desc;
  
  int min_count, max_count;
  bool needs_arg, fragmented;
  int count;
};

template <typename T> 
class Argument : public BasicArgument {
 
 public:
  
  Argument (const std::string& i_sname, const std::string& i_lname,
	    const std::string& i_desc,
	    int i_min_count = 0, int i_max_count = 0, bool i_fragmented = false) 
    : BasicArgument (i_sname, i_lname, i_desc, i_min_count, i_max_count, i_fragmented)
  {
    // if bool (or other special option) always containing one value
    if (!needs_arg)
      values.push_back (T () );
  }

  Argument (const std::string& i_sname, const std::string& i_lname,
	    const std::string& i_desc, 
	    const T& i_value, int i_min_count = 0, int i_max_count = 0,
	    bool i_fragmented = false)
    : BasicArgument (i_sname, i_lname, i_desc, i_min_count, i_max_count, i_fragmented)
  {
    values.push_back (i_value);
    // if bool (or other special option) always containing one value
    if (!needs_arg)
      values.push_back (T () );
  }
  
  bool Read () {
    std::cout << "Error: Argument " << lname << " needs an parameter!" << std::endl;
    return false;
  }
  
  bool Read (const std::string& arg) {
    if (count >= max_count) {
      std::cout << "Error: Too many parameter for argument " << lname
		<< ", only " << max_count << " allowed!" << std::endl;
      return false;
    }
    
    std::stringstream stream (arg);
    // TODO: error handling
    T value;
    stream >> value;
    
    // special case if default was supplied -> overwrite the first ...
    if (count == 0 & values.size () > 0)
      values[0] = value;
    else
      values.push_back (value);
    
    ++count;
    
    return true;
  }

  bool Interrupt () {
    if (!this->fragmented && count < min_count) {
      std::cout << "Error: No fragmentation for argument " << lname << " allowed!"
		<< std::endl
		<< "       At least " << min_count << " parameter required!" << std::endl;
      return false;
    }
    return true;
  }
  
  bool Finalize () {
    if (count < min_count) {
      std::cout << "Error: Too few parameter for argument " << lname
		<< ", at least " << min_count << " required!" << std::endl;
      return false;
    }
    return true;
  }
  
  T Get (unsigned int i = 0) {
    if (values.size () > i) {
      return values [i];
    }
    else
      std::cout << "Error: There is no parameter: " << i
		<< " present for argument " << this->lname << std::endl;
    return T ();
  }
  
private:
  std::vector<T> values;
};

// some bool specialisations ...
template <> bool Argument<bool>::Read ();
template <> bool Argument<bool>::Read (const std::string& arg);

class ArgumentList {

 public:

  // register a to be parsed argument
  void Add (BasicArgument* arg);
  // parse options specified
  bool Read (int argc, char** argv);
  
  // printout the usual usage list, generated from the
  // registered arguments
  void Usage (const std::ostream& os);
  
 private:
  typedef std::map<std::string, BasicArgument*> container;
  typedef container::iterator iterator;
  
  container short_content;
  container long_content;
};

#include "template/ArgumentList.tcc"

#endif // UTILITY__ARGUMENTLIST_HH__
