/*
 * --- GSMP-COPYRIGHT-NOTE-BEGIN ---
 * 
 * This copyright note is auto-generated by ./scripts/Create-CopyPatch.
 * Please add additional copyright information _after_ the line containing
 * the GSMP-COPYRIGHT-NOTE-END tag. Otherwise it might get removed by
 * the ./scripts/Create-CopyPatch script. Do not edit this copyright text!
 * 
 * GSMP: utility/include/ArgumentList.hh
 * General Sound Manipulation Program is Copyright (C) 2000 - 2004
 *   Valentin Ziegler and René Rebe
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2. A copy of the GNU General
 * Public License can be found in the file LICENSE.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANT-
 * ABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
 * Public License for more details.
 * 
 * --- GSMP-COPYRIGHT-NOTE-END ---
 */

#ifndef UTILITY__ARGUMENTLIST_HH__
#define UTILITY__ARGUMENTLIST_HH__

#include <iostream>

#include <map>
#include <vector>

class BasicArgument {
 public:
  
  BasicArgument (const std::string& i_sname, const std::string& i_lname,
		 const std::string& i_desc,  int i_min_count, int i_max_count);
  
  virtual ~BasicArgument ();
  
  virtual bool Read () = 0;
  virtual bool Read (const std::string& arg) = 0;
  
  std::string sname;
  std::string lname;
  std::string desc;
  
  bool needs_arg;
  int min_count, max_count;
  int count;
};

template <typename T> 
class Argument : public BasicArgument {
 
 public:
  
  Argument (const std::string& i_sname, const std::string& i_lname,
	    const std::string& i_desc,
	    int i_min_count = 0, int i_max_count = 0) 
    : BasicArgument (i_sname, i_lname, i_desc, min_count, max_count)
  {
    // if bool (or other special option) always containing one value
    if (!needs_arg)
      values.push_back (T () );
  }

  Argument (const std::string& i_sname, const std::string& i_lname,
	    const std::string& i_desc, 
	    const T& i_value, int min_count = 0, int max_count = 0)
    : BasicArgument (i_sname, i_lname, i_desc, min_count, max_count)
  {
    values.push_back (i_value);
    // if bool (or other special option) always containing one value
    if (!needs_arg)
      values.push_back (T () );
  }
  
  bool Read () {
    std::cout << "Error: Option " << lname << " needs an argument!" << std::endl;
    return false;
  }
  
  bool Read (const std::string& arg) {
    if (count >= max_count) {
      std::cout << "Error: Too many arguments for option " << lname
		<< ", only " << max_count << " allowed!" << std::endl;
      return false;
    }
    
    std::stringstream stream (arg);
    // TODO: error handling
    T value;
    stream >> value;
    
    // special case if default was supplied -> overwrite the first ...
    if (count == 0 & values.size () > 0)
      values[0] = value;
    else
      values.push_back (value);
    
    ++count;
    
    return true;
  }
  
  std::vector<T> values;
};

// some bool specialisations ...
template <> bool Argument<bool>::Read ();
template <> bool Argument<bool>::Read (const std::string& arg);

class ArgumentList {

 public:

  void Add (BasicArgument* arg);
  bool Read (int argc, char** argv);
  
  void Usage (const std::ostream& os);
  
  template <typename T>
  T Get (const std::string& name, unsigned int i = 0) {
    
    iterator it = long_content.find (name);
    
    if (it == long_content.end () ) {
      it = short_content.find (name);
      if (it == short_content.end () ) {
	std::cout << "Warning: Argument " << name << " not available!"
		  << std::endl;
	return T ();
      }
    }
    
    Argument<T>* s;
    s = dynamic_cast<Argument<T>*> (it->second);
    if (s) {
      if (s->values.size () > i) {
	return s->values [i];
      }
      else
	std::cout << "Error: There is no value " << i << "present for argument "
		  << name << std::endl;
    }
    else
      std::cout << "Error: Type mismatch for argument " << name << "!"
		<< std::endl;
    return T ();
  }
  
 private:
  typedef std::map<std::string, BasicArgument*> container;
  typedef container::iterator iterator;
  
  container short_content;
  container long_content;
};

#include "ArgumentList.tcc"

#endif // UTILITY__ARGUMENTLIST_HH__
