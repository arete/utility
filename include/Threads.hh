
/*
 * --- GSMP-COPYRIGHT-NOTE-BEGIN ---
 * 
 * This copyright note is auto-generated by ./scripts/Create-CopyPatch.
 * Please add additional copyright information _after_ the line containing
 * the GSMP-COPYRIGHT-NOTE-END tag. Otherwise it might get removed by
 * the ./scripts/Create-CopyPatch script. Do not edit this copyright text!
 * 
 * GSMP: utility/include/Threads.hh
 * General Sound Manipulation Program is Copyright (C) 2000 - 2003
 *   Valentin Ziegler and René Rebe
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2. A copy of the GNU General
 * Public License can be found in the file LICENSE.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANT-
 * ABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
 * Public License for more details.
 * 
 * --- GSMP-COPYRIGHT-NOTE-END ---
 */

/*
 * A Pthread wrapper based on a former implementation from the sigc++
 * package by Karl Nelson.
 *
 */

#ifndef UTILITY__THREAD_HH__
#define UTILITY__THREAD_HH__

// ?? ...
#define THREAD_API

#include <pthread.h>

namespace Utility
{
  namespace Threads
  {
    struct CondAttr { pthread_condattr_t* impl_; };
    struct MutexAttr { pthread_mutexattr_t* impl_; };
    struct ThreadAttr { pthread_attr_t* impl_; };

    typedef pthread_mutex_t MutexImpl;
    typedef pthread_cond_t CondImpl;
    typedef pthread_key_t KeyImpl;
    typedef pthread_t ThreadImpl;

    // Mutual Exclusion
    class Mutex
    {
      typedef MutexImpl Impl;
    
    public:
      
      static THREAD_API MutexAttr Default;
      operator Impl* ()  { return (Impl*)(&mutex_); }

      Mutex (const MutexAttr attr = Default) {
	pthread_mutex_init (&mutex_, attr.impl_);
      };
      
      // (needs work) 
      ~Mutex() { destroy (); };
      
      int lock () { return pthread_mutex_lock(&mutex_); };
      int trylock() { return pthread_mutex_trylock(&mutex_); };
      int unlock() { return pthread_mutex_unlock(&mutex_); };
      
    private:
      Impl mutex_;
      int destroy() { return pthread_mutex_destroy(&mutex_); };
    };

    // A lazy way to unlock at end of scope
    class MLock
    {
    public:
      MLock (Mutex& mutex):mutex_(mutex) { mutex_.lock(); };
      ~MLock () { mutex_.unlock(); };
      
    private:
      Mutex &mutex_;
    };

    // Condition Variable
    class Condition
    {
    private:
      typedef CondImpl Impl;
    
    public:
      static THREAD_API CondAttr Default;
      operator Impl* ()  { return (Impl*)(&cond_); };

      Condition (const CondAttr &attr = Default) {
	pthread_cond_init (&cond_,attr.impl_);
      };
	
      ~Condition () { destroy (); };
      
      // restarts exactly one thread hung on condition
      int signal()       { return pthread_cond_signal (&cond_); }

      // restarts all threads waiting on condition
      int broadcast()    { return pthread_cond_broadcast(&cond_); }

      // unlocks a mutex while waiting on a condition, then reaquires lock.
      int wait(Mutex &m) { return pthread_cond_wait (&cond_,m); }

      // unlocks a mutex while waiting on a condition, then reaquires lock
      // with a fixed maximum duration.
      int wait (Mutex &m, struct timespec* spec) {
	return pthread_cond_timedwait (&cond_, m, spec);
      }
      
    private:
      Impl cond_;
      
      int destroy () { return pthread_cond_destroy (&cond_); }
    };

    // Integer Semaphore
    class Semaphore
    {
    public:
      Semaphore (int value = 1)
	: value_ (value) {}
      ~Semaphore () {}
      
      void up();
      void down();
      
    private:
      int value_;
      Condition sig_;
      Mutex access_;
    };
    
    /* This is a very basic thread skeleton which does not perform
     * and automatic operation (such as joining in the dtor ...)
     */
    class Thread
    {
    protected:
      typedef ThreadImpl Impl;
      static THREAD_API ThreadAttr Default;
      
    public:
      Thread (const ThreadAttr& attr = Default);
      virtual ~Thread ();

      int detach ();
      void* join ();
      
      // arg is for passing extra data to main, but never pass a
      // local variable or address of local variable. Arg must
      // be available throughout life of program.
      int start (void* arg = 0);

      operator Impl* () { return &thread_; }
      
    protected:
      
      // the real code for the thread
      virtual void* main (void* arg) = 0;
      
      // trampolines
      void* call_main_ (void* arg);
      static void* call_main_static_ (void* arg);
      
      Impl thread_;
      void* arg_;
      ThreadAttr attr_;
    };
    
  } /* namespace Threads */
} /* namespace Utility */

#endif /* __UTILITY_THREAD_HH__ */
