/*
 * --- GSMP-COPYRIGHT-NOTE-BEGIN ---
 * 
 * This copyright note is auto-generated by ./scripts/Create-CopyPatch.
 * Please add additional copyright information _after_ the line containing
 * the GSMP-COPYRIGHT-NOTE-END tag. Otherwise it might get removed by
 * the ./scripts/Create-CopyPatch script. Do not edit this copyright text!
 * 
 * GSMP: utility/src/DirIterator.cc
 * General Sound Manipulation Program is Copyright (C) 2000 - 2003
 *   Valentin Ziegler and René Rebe
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2. A copy of the GNU General
 * Public License can be found at LICENSE.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANT-
 * ABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
 * Public License for more details.
 * 
 * --- GSMP-COPYRIGHT-NOTE-END ---
 */

#include "DirIterator.hh"

#include <sys/types.h>
#include <sys/stat.h>

#include <iostream>
#include <sstream> // for stringstream

int Utility::FindUniqueName (std::string& fname, const std::string& base,
			     const std::string& ext, int first_tried_index)
{
  std::stringstream t_fname;
  
  int t_index = first_tried_index;
  bool t_found = false;
  while (!t_found)
    {
      t_fname.str ("");
      t_fname << base << t_index << ext;
      std::cout << "testing: (statting): " << t_fname.str () << std::endl;
      struct stat t_stat;
      if (stat (t_fname.str().c_str (), &t_stat) < 0)
	t_found = true;
      else
	++ t_index;
    }
  fname = t_fname.str ();
  return t_index;
}


Utility::DirIterator::DirIterator (const std::string& i_dir)
{
  m_open = false;
  m_end = false;
  Open (i_dir);
}

Utility::DirIterator::~DirIterator ()
{
  if (m_open)
    Close ();
}

bool Utility::DirIterator::Open (const std::string& n_dirname)
{
  if (m_open)
    return false;
  
  m_dirname = n_dirname;
  
  m_internal_dir = opendir (m_dirname.c_str () );
  if (m_internal_dir == 0)
    return false;
  
  m_open = true;
  m_end = false;
  
  Next ();
  
  return true;
}

bool Utility::DirIterator::Close ()
{
  if (!m_open)
    return false;
  
  if (closedir (m_internal_dir) < 0)
    return false;
  
  m_open = false;
  return true;
}

const Utility::DirIterator& Utility::DirIterator::operator++ ()
{
  Next ();
}

const Utility::DirIterator& Utility::DirIterator::operator++ (int)
{
  Next ();
}

bool Utility::DirIterator::End ()
{
  return m_end;
}

const std::string& Utility::DirIterator::operator* ()
{
  return m_entry_name;
}


void Utility::DirIterator::Next ()
{
  if (!m_open)
    return;
  
  m_internal_dir_entry = readdir (m_internal_dir);
  if (m_internal_dir_entry == 0) {
    m_entry_name = "";
    m_end = true;
    return;
  }
  
  m_entry_name = m_internal_dir_entry->d_name;
}
